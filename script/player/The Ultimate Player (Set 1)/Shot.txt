
task TShotAll {
    TShotMarisa;
    TShot2Marisa;
}
let lightArray;
let shotEffect1Array;
task TShotMarisa {
    lightArray =
        CreateParticleListRect(OBJ_PARTICLE_LIST_2D, IMG_LIGHT,
                               [ 0, 0, 512, 512 ], BLEND_ADD_ARGB, 0.43);
    shotEffect1Array = CreateParticleListRect(
        OBJ_PARTICLE_LIST_2D, IMG_SHOT, [ 49, 97, 63, 128 ], BLEND_ALPHA, 0.43);
    let pShot = false;
    ShotCheck;
    let Speed = 22.5;
    let MainDamage = 3.0;
    let DamageRate = 1 * 2;
    loop {
        while (!pShot) {
            yield;
        }
        if (IsPlayerSpellActive) {
            DamageRate = 0.5 * 2;
        } else {
            DamageRate = 1.0 * 2;
        }
        MainDamage = debugDamageRate ? 300 : 3;
        
        MainShot(GetPlayerX() + 8, GetPlayerY(), Speed, 270, MainDamage, 20);
        MainShot(GetPlayerX() - 8, GetPlayerY(), Speed, 270, MainDamage, 20);
        MainShot(GetPlayerX(), GetPlayerY(), Speed, 270, MainDamage / 2, 20);
        SE_PlayLen(SE_SHOT, 50);

        loop(3) {
            ascent(i in 0..4) { Light(i, [ 255, 255, 0 ], 1); }
            yield;
        }
    }

    task ShotCheck {
        loop {
            if ((GetVirtualKeyState(VK_SHOT) == KEY_PUSH ||
                 GetVirtualKeyState(VK_SHOT) == KEY_HOLD) &&
                GetPlayerState == STATE_NORMAL && IsPermitPlayerShot &&
                SELECT_PLAYER == SELECT_MARISA && !OnSpell) {
                pShot = true;

            } else {
                pShot = false;
            }
            yield;
        }
    }

    task MainShot(x, y, speed, angle, damage, id) {
        let obj = CreatePlayerShotA1(x, y, speed, angle, damage, 1, id);
        // ObjRender_SetBlendType(obj,BLEND_ADD_ARGB);
        let scale = 1;
        ObjRender_SetScaleXYZ(obj, scale, scale, scale);
        Obj_SetRenderPriorityI(obj, 40);
        let OldX;
        let OldY;
    }
}
task Light(id, color, type) {
    let time = 10;
    ascent(i in 0..time) {
        ObjParticleList_SetAlpha(lightArray, 255 - 255 / time * i);
        ObjParticleList_SetScale(lightArray, 0.15 / time * i, 0.15 / time * i,
                                 0);
        ObjParticleList_SetPosition(lightArray, OptionX[id], OptionY[id], 0);
        ObjParticleList_SetColor(lightArray, 255 - color[0] / time * i,
                                 255 - color[1] / time * i,
                                 255 - color[2] / time * i);
        ObjParticleList_AddInstance(lightArray);
        yield;
    }
}
task TShot2Marisa {  // サブ
    let pShot = false;

    let ShotLagCount = 0;
    let ShotAngle_P4 = [ -90, -90, -90, -90 ];
    let ShotAngle = [ ShotAngle_P4, ShotAngle_P4, ShotAngle_P4, ShotAngle_P4 ];
    let c = 0;
    ShotCheck;
    let laserLength = 0;
    let laserWidth = 0;
    ascent(i in 0..4) {
        LaserTask(i, 0);
        LaserTask(i, 1);
    }
    loop {
        while (!pShot) {
            yield;
        }
        if (GetVirtualKeyState(VK_SLOWMOVE) == KEY_PUSH ||
            GetVirtualKeyState(VK_SLOWMOVE) == KEY_HOLD) {
            ascent(i in 0..4) {
                if (c % 12 == [ 0, 6, 6, 0 ][i]) {
                    MissileShot(OptionX[i], OptionY[i], 270, 0);
                }
            }
        } else {
            if (c % 6 == 0) {
            }
        }
        ascent(i in 0..4) {
            if (GetVirtualKeyState(VK_SLOWMOVE) == KEY_PUSH ||
                GetVirtualKeyState(VK_SLOWMOVE) == KEY_HOLD) {
                ShotAngle_P4[i] = ShotAngle_P4[i] * 0.9 + (-90) * 0.1;
            } else {
                ShotAngle_P4[i] =
                    ShotAngle_P4[i] * 0.9 + (-90 - 10 + 20 / 3 * i) * 0.1;
            }
        }
        c++;
        loop(1) { yield; }
    }

    task ShotCheck {
        loop {
            if ((GetVirtualKeyState(VK_SHOT) == KEY_PUSH ||
                 GetVirtualKeyState(VK_SHOT) == KEY_HOLD) &&
                GetPlayerState == STATE_NORMAL && IsPermitPlayerShot &&
                SELECT_PLAYER == SELECT_MARISA && !OnSpell) {
                pShot = true;

            } else {
                pShot = false;
            }
            yield;
        }
    }

    task LaserTask(id, type) {
        let obj = ObjPrim_Create(OBJ_PRIMITIVE_2D);
        ObjPrim_SetTexture(obj, IMG_LASER);
        ObjPrim_SetPrimitiveType(obj, PRIMITIVE_TRIANGLEFAN);
        ObjPrim_SetVertexCount(obj, 4);
        ObjRender_SetBlendType(obj, BLEND_ADD_ARGB);
        Obj_SetRenderPriorityI(obj, 40);
        ObjRender_SetAngleZ(obj, 0);

        ObjPrim_SetDestCenter(obj, 0 + 16 * type, 0, 16 + 16 * type, 256);
        let Leng = 0;
        let AnimeCount = 0;
        let width = 0;
        let maxwidth = 8;
        ObjRender_SetAlpha(obj, 75);
        if (type == 1) {
            ObjRender_SetAlpha(obj, 50);
            maxwidth = 16;
        }
        let RG = 255;
        let angleCos = cos(ShotAngle_P4[id]);
        let angleSin = sin(ShotAngle_P4[id]);
        loop {
            ObjRender_SetPosition(obj, OptionX[id], OptionY[id], 0);

            if (pShot == true && GetVirtualKeyState(VK_SLOWMOVE) == KEY_FREE) {
                if (width == 0) {
                    width = maxwidth;
                } else if (width < maxwidth) {
                    width += maxwidth / 15;
                } else {
                    width = maxwidth;
                }
            } else {
                if (width > 0) {
                    width -= maxwidth / 5;
                } else {
                    Leng = 0;
                }
            }
            if (width > 0) {
                if (Leng < GetStgFrameHeight + 100) {
                    Leng += 20;
                }
            }
            laserWidth = width;
            laserLength = Leng;
            ObjPrim_SetVertexUVT(obj, 0, 0 + 16 * type, AnimeCount);
            ObjPrim_SetVertexUVT(obj, 1, 16 + 16 * type, AnimeCount);
            ObjPrim_SetVertexUVT(obj, 2, 16 + 16 * type, Leng + AnimeCount);
            ObjPrim_SetVertexUVT(obj, 3, 0 + 16 * type, Leng + AnimeCount);

            ObjPrim_SetVertexPosition(obj, 0, -width, 0, -0);
            ObjPrim_SetVertexPosition(obj, 1, width, 0, -0);
            ObjPrim_SetVertexPosition(obj, 2, width, Leng, 0);
            ObjPrim_SetVertexPosition(obj, 3, -width, Leng, 0);
            ObjRender_SetAngleZ(obj, ShotAngle_P4[id] - 90);
            AnimeCount -= 16;
            ObjRender_SetColor(obj, RG, RG, 255);
            if (GetPlayerState == STATE_NORMAL && IsPermitPlayerShot &&
                !OnSpell && Leng > 0 && width > 0) {
                angleCos = cos(ShotAngle_P4[id]);
                angleSin = sin(ShotAngle_P4[id]);
                let objS = CreatePlayerShotA1(OptionX[id], OptionY[id], 0, 0,
                                              0.9, 9999999, 1);
                ObjShot_SetIntersectionLine(objS, OptionX[id], OptionY[id],
                                            OptionX[id] + Leng * angleCos,
                                            OptionY[id] + Leng * angleSin,
                                            width * 2);
                yield;
                if (ObjCol_IsIntersected(objS)) {
                    RG = RG * 0.9 + 128 * 0.1;
                } else {
                    RG = RG * 0.9 + 255 * 0.1;
                }
                Obj_Delete(objS);
            } else {
                RG = RG * 0.9 + 255 * 0.1;
                yield;
            }
        }
    }
    task MissileShot(x, y, angle, Opnum) {
        let speed = 3;
        let speedPlus = 2;
        let obj = CreatePlayerShotA1(x, y, speed, angle, 0, 1, 23);
        Obj_SetRenderPriorityI(obj, 40);
        let scale = 1.0;
        ObjRender_SetScaleXYZ(obj, scale, scale, scale);
        let count = 2;
        let OldX = x;
        let OldY = y;
        let Alpha = 255;

        loop(6) {
            OldX = ObjMove_GetX(obj);
            OldY = ObjMove_GetY(obj);
            count += 1;
            yield;
        }
        ObjMove_SetAcceleration(obj, 1.5);
        ObjMove_SetMaxSpeed(obj, 100);
    }
}
